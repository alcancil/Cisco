<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simulado Multicast - 05</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 flex items-center justify-center min-h-screen p-6">

  <div class="w-full max-w-2xl bg-white shadow-lg rounded-xl p-6">
    <div id="start-screen" class="text-center">
      <h1 class="text-2xl font-bold mb-4">Simulado Multicast - IGMP (Parte 2)</h1>
      <p class="mb-6 text-slate-600">Este simulado contém 10 questões sobre IGMP. Você terá 10 minutos para concluir.</p>
      <div class="max-w-sm mx-auto mb-4">
        <label for="user-name" class="block text-left text-sm font-medium text-slate-700 mb-1">Seu nome</label>
        <input id="user-name" type="text" placeholder="Digite seu nome" class="w-full px-3 py-2 rounded-lg border" />
      </div>
      <button onclick="startQuiz()" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Iniciar</button>
    </div>

    <div id="quiz-screen" class="hidden">
      <div class="flex justify-between items-center mb-4">
        <span id="question-count" class="text-sm font-semibold text-slate-500">Questão 1 de 10</span>
        <span id="quiz-timer" class="text-sm font-semibold text-slate-500">10:00</span>
      </div>
      <h2 id="question-text" class="text-xl font-semibold mb-6"></h2>
      <div id="options-container" class="space-y-3"></div>
      <div class="flex justify-between items-center mt-6">
        <button id="next-btn" onclick="nextQuestion()" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 hidden">Próximo</button>
      </div>
    </div>

    <div id="result-screen" class="hidden">
      <h2 class="text-2xl font-bold text-center mb-4">Resultados</h2>
      <p id="score-el" class="text-lg text-center mb-6"></p>
      <div id="review-el"></div>
    </div>
  </div>

<script>
  const SIMULADO_ID = 'simulado_05';
  const SIMULADO_TITULO = 'Simulado Multicast - IGMP (Parte 2)';

  const quizData = [
    {
      "question": "Um roteador multicast IGMPv2 com um endereço IP `192.168.1.1` e outro roteador com `192.168.1.5` estão na mesma rede. Qual roteador se tornará o 'Querier' e por quê?",
      "options": ["O roteador com `192.168.1.5`, porque tem um endereço IP maior.", "O roteador com `192.168.1.1`, porque tem um endereço IP menor.", "O roteador com `192.168.1.1`, por ser o primeiro a ligar.", "O roteador com `192.168.1.5`, por ser o mais novo na rede."],
      "answer": 1,
      "rationale": "O roteador com o menor endereço IP na interface se torna o 'Querier', pois os roteadores com endereços IP maiores cessam de enviar as consultas."
    },
    {
      "question": "No IGMPv3, um host envia uma mensagem 'Report' para o endereço `224.0.0.22` com o modo 'Exclude'. Qual é a finalidade dessa mensagem?",
      "options": ["Para se juntar a um grupo multicast e ouvir todas as fontes, exceto as listadas no relatório.", "Para sair de um grupo multicast específico.", "Para solicitar que o roteador não envie mensagens de consulta.", "Para solicitar tráfego multicast de uma fonte específica."],
      "answer": 0,
      "rationale": "Esta é a definição do modo 'Exclude'. A mensagem indica que o host deseja ingressar no grupo e aceitar tráfego de todas as fontes, exceto aquelas especificamente excluídas na lista."
    },
    {
      "question": "Um host conectado a um switch está no grupo multicast `224.1.1.1`. Para evitar o 'flooding' de tráfego multicast, o switch está executando o IGMP Snooping. Quando o host para de ouvir o grupo, que ação o switch pode tomar?",
      "options": ["O switch continua a enviar o tráfego do grupo para o host até que o timer de expiração expire.", "O switch notifica o roteador multicast de que o host saiu do grupo.", "O switch remove a porta do host da tabela de encaminhamento para o grupo `224.1.1.1` imediatamente ao detectar a saída do grupo.", "O switch envia uma 'General Query' para verificar a presença de outros membros do grupo."],
      "answer": 2,
      "rationale": "O IGMP Snooping permite que o switch remova a porta do host da sua tabela de encaminhamento para o grupo, evitando o 'flooding' do tráfego multicast."
    },
    {
      "question": "No contexto de roteamento multicast, qual dos seguintes protocolos opera na Camada 3 e é o equivalente do IGMP para redes IPv6?",
      "options": ["Protocolo de Roteamento de Multicast (PIM).", "Protocolo de Descoberta de Vizinhos (NDP).", "Protocolo de Gerenciamento de Membros de Multicast (MLD).", "Protocolo de Túnel de IPv6 (6to4)."],
      "answer": 2,
      "rationale": "O MLD (Multicast Listener Discovery) é o protocolo equivalente ao IGMP, utilizado em redes IPv6 para que os roteadores descubram e mantenham a informação de quais hosts estão interessados em quais grupos de multicast."
    },
    {
      "question": "Um roteador IGMPv2 está na mesma rede que um roteador IGMPv3. O que ocorrerá com a eleição do 'Querier'?",
      "options": ["O roteador IGMPv3 será eleito como 'Querier', independentemente de seu endereço IP.", "O roteador IGMPv2 será eleito, e o IGMPv3 não participará da eleição.", "A eleição falhará e nenhum 'Querier' será eleito.", "A eleição será baseada no menor endereço IP. O roteador IGMPv3 operará em modo de compatibilidade com IGMPv2."],
      "answer": 3,
      "rationale": "Essa é a resposta correta. O roteador IGMPv3, ao detectar um roteador IGMPv2, opera em modo de compatibilidade com o IGMPv2. A eleição é então baseada no menor endereço IP, e o roteador IGMPv3 envia consultas IGMPv2 para manter a interoperabilidade."
    },
    {
      "question": "Um host envia um 'Group Membership Report' para um roteador IGMPv1. Qual campo da mensagem deve ser obrigatoriamente `0.0.0.0`?",
      "options": ["O campo 'IP Source Address'.", "O campo 'IP Destination Address'.", "O campo 'Group Address'.", "O campo 'Querier IP Address'."],
      "answer": 3,
      "rationale": "O campo 'Querier IP Address' é usado para identificar o 'Querier' no IGMPv2 e no IGMPv3, mas em um 'Report' do IGMPv1 este campo é definido como '0.0.0.0' por ser irrelevante, já que o IGMPv1 não tem um mecanismo de eleição de 'Querier' formal."
    },
    {
      "question": "Um roteador multicast está enviando uma 'General Query' (Consulta Geral) com um 'Maximum Response Time' de 10 segundos. Qual é a principal implicação desse tempo para os hosts na rede?",
      "options": ["Os hosts devem responder à consulta em exatamente 10 segundos.", "O roteador aguardará 10 segundos antes de enviar outra consulta.", "Os hosts devem iniciar um timer aleatório com um valor entre 0 e 10 segundos para enviar seu 'Report'.", "Os hosts que não responderem dentro de 10 segundos são removidos do grupo imediatamente."],
      "answer": 2,
      "rationale": "Os hosts iniciam um timer aleatório entre 0 e o valor do 'Maximum Response Time' para evitar 'rajadas de tráfego' ('report bursts')."
    },
    {
      "question": "Um host, membro de um grupo multicast, recebe uma 'Group-Specific Query' (Consulta Específica de Grupo) para o grupo `239.1.1.1` com o 'Source IP' `10.1.1.50`. Qual é o propósito desta mensagem?",
      "options": ["O roteador está verificando se há hosts que desejam receber tráfego de qualquer fonte para o grupo.", "O roteador está confirmando a presença do host no grupo e verificando se ele deseja receber tráfego de uma fonte específica.", "O roteador está verificando se há hosts que ainda são membros do grupo após uma mensagem de 'Leave Group'.", "O roteador está solicitando que o host saia do grupo `239.1.1.1`."],
      "answer": 2,
      "rationale": "Quando um roteador recebe uma 'Leave Group' de um host, ele envia uma 'Group-Specific Query' para verificar se há outros hosts que ainda são membros daquele grupo antes de remover a rota de multicast da sua tabela de roteamento."
    },
    {
      "question": "Em um host que usa IGMPv3, qual é o estado de uma entrada de grupo quando o host está configurado para receber tráfego de **todas** as fontes exceto uma lista específica de endereços?",
      "options": ["State is `TO_IN` (Transition to Include).", "State is `ISL` (Include Source List).", "State is `IS_EX` (Is Exclude).", "State is `IS_IN` (Is Include)."],
      "answer": 2,
      "rationale": "O estado `IS_EX` (Is Exclude) é o estado final de exclusão. Ele indica que o host está recebendo tráfego de todas as fontes para o grupo, exceto as listadas no relatório."
    },
    {
      "question": "O Protocolo de Gerenciamento de Grupo da Internet (IGMP) é um componente chave do quebra-cabeça do roteamento multicast. Sua principal função é:",
      "options": ["Construir e manter tabelas de roteamento multicast para os roteadores.", "Gerenciar a adesão de membros de grupos multicast em uma rede local.", "Realizar a descoberta e a comunicação entre roteadores vizinhos para o tráfego multicast.", "Realizar a conversão de endereços IP multicast para endereços MAC de camada 2."],
      "answer": 1,
      "rationale": "A principal função do IGMP é permitir que hosts e roteadores em uma rede local gerenciem a adesão de hosts a grupos de multicast, informando os roteadores quais hosts em quais sub-redes desejam receber tráfego para quais grupos."
    }
  ];
  
  // --- Código JavaScript do Quiz (pode ser reutilizado de 01.html) ---
  const startScreen = document.getElementById('start-screen');
  const quizScreen = document.getElementById('quiz-screen');
  const resultScreen = document.getElementById('result-screen');
  const questionText = document.getElementById('question-text');
  const optionsContainer = document.getElementById('options-container');
  const nextBtn = document.getElementById('next-btn');
  const questionCount = document.getElementById('question-count');
  const quizTimer = document.getElementById('quiz-timer');
  const scoreEl = document.getElementById('score-el');
  const reviewEl = document.getElementById('review-el');
  const userNameInput = document.getElementById('user-name');
  
  let currentQuestionIndex = 0;
  let userAnswers = [];
  let score = 0;
  let timer;
  let timeSpentSeconds = 0;
  let currentUserName = '';

  const MAX_TIME = 600; // 10 minutes

  function formatSeconds(secs) {
      const minutes = Math.floor(secs / 60);
      const seconds = secs % 60;
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  function startQuiz() {
      const name = userNameInput.value.trim();
      if (!name) {
          alert("Por favor, digite seu nome para começar.");
          return;
      }
      currentUserName = name;
      startScreen.classList.add('hidden');
      quizScreen.classList.remove('hidden');
      timeSpentSeconds = 0;
      quizTimer.textContent = formatSeconds(MAX_TIME);
      userAnswers = [];
      score = 0;
      currentQuestionIndex = 0;
      timer = setInterval(() => {
          timeSpentSeconds++;
          quizTimer.textContent = formatSeconds(MAX_TIME - timeSpentSeconds);
          if (timeSpentSeconds >= MAX_TIME) {
              endQuiz();
          }
      }, 1000);
      showQuestion();
  }

  function showQuestion() {
      const question = quizData[currentQuestionIndex];
      questionText.textContent = question.question;
      optionsContainer.innerHTML = '';
      questionCount.textContent = `Questão ${currentQuestionIndex + 1} de ${quizData.length}`;
      nextBtn.classList.add('hidden');

      question.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.textContent = option;
          button.className = 'w-full text-left p-4 border rounded-lg bg-gray-50 hover:bg-gray-100 transition-colors';
          button.onclick = () => selectAnswer(index);
          optionsContainer.appendChild(button);
      });
  }

  function selectAnswer(selectedIndex) {
      if (userAnswers[currentQuestionIndex] !== undefined) return;
      userAnswers[currentQuestionIndex] = selectedIndex;
      
      const isCorrect = (selectedIndex === quizData[currentQuestionIndex].answer);
      if (isCorrect) {
          score++;
      }
      
      const buttons = optionsContainer.getElementsByTagName('button');
      for (let i = 0; i < buttons.length; i++) {
          const button = buttons[i];
          if (i === quizData[currentQuestionIndex].answer) {
              button.classList.add('bg-green-200', 'border-green-600');
          } else if (i === selectedIndex) {
              button.classList.add('bg-red-200', 'border-red-600');
          }
          button.disabled = true;
      }
      nextBtn.classList.remove('hidden');
  }

  function nextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex < quizData.length) {
          showQuestion();
      } else {
          endQuiz();
      }
  }

  function endQuiz() {
    const resultRecord = {
        id: String(Date.now()),
        simuladoId: SIMULADO_ID,
        simuladoTitle: SIMULADO_TITULO,
        name: currentUserName,
        score: score,
        total: quizData.length,
        percent: quizData.length ? (score / quizData.length) * 100 : 0,
        timeSeconds: timeSpentSeconds,
        timeFormatted: formatSeconds(timeSpentSeconds),
        date: new Date().toISOString()
    };

    let results = JSON.parse(localStorage.getItem('quizResults')) || [];
    results.push(resultRecord);
    localStorage.setItem('quizResults', JSON.stringify(results));
      
      clearInterval(timer);
      quizScreen.classList.add("hidden");
      resultScreen.classList.remove("hidden");

      const pct = quizData.length ? Math.round((score/quizData.length)*100) : 0;
      scoreEl.textContent = `Você acertou ${score} de ${quizData.length} questões (${pct}%). Tempo: ${formatSeconds(timeSpentSeconds)}.`;

      reviewEl.innerHTML = quizData.map((q, i) => {
          const isCorrect = userAnswers[i] === q.answer;
          const resultClass = isCorrect ? "bg-green-100 border-green-600" : "bg-red-100 border-red-600";
          const userOptionText = q.options[userAnswers[i]] || 'Não respondida';
          const correctOptionText = q.options[q.answer];

          return `
            <div class="p-4 border rounded-lg ${resultClass} mb-4">
              <p class="font-semibold">Q${i+1}: ${q.question}</p>
              <p class="text-sm">Sua Resposta: <span class="${isCorrect ? 'text-green-600' : 'text-red-600'} font-medium">${userOptionText}</span></p>
              ${!isCorrect ? `<p class="text-sm">Resposta Correta: <span class="text-green-600 font-medium">${correctOptionText}</span></p>` : ''}
              <p class="mt-2 text-sm text-slate-700">Explicação: ${q.rationale}</p>
            </div>
          `;
      }).join('');
  }
</script>
</body>
</html>