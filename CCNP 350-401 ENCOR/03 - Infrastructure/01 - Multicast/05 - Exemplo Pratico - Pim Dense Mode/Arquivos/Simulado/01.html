<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simulado Multicast</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 flex items-center justify-center min-h-screen p-6">

  <div class="w-full max-w-2xl bg-white shadow-lg rounded-xl p-6">
    <div id="start-screen" class="text-center">
      <h1 class="text-2xl font-bold mb-4">Simulado Multicast</h1>
      <p class="mb-6 text-slate-600">Este simulado cont√©m 10 quest√µes sobre Multicast. Voc√™ ter√° 10 minutos para concluir.</p>
      <div class="max-w-sm mx-auto mb-4">
  <label for="user-name" class="block text-left text-sm font-medium text-slate-700 mb-1">Seu nome</label>
  <input id="user-name" type="text" placeholder="Digite seu nome" class="w-full px-3 py-2 rounded-lg border" />
</div>
<button onclick="startQuiz()" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Iniciar</button>
    </div>

    <div id="quiz-screen" class="hidden">
      <div class="flex justify-between items-center mb-4">
        <span id="timer" class="font-semibold text-slate-700">Tempo: 10:00</span>
        <span id="question-number" class="font-semibold text-slate-700">1</span>
      </div>

      <div class="w-full bg-slate-200 rounded-full h-3 mb-6">
        <div id="progress-bar" class="bg-blue-600 h-3 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>

      <h2 id="question-text" class="text-lg font-semibold mb-4"></h2>
      <div id="options" class="space-y-3"></div>
      <button id="next-btn" onclick="nextQuestion()" disabled class="mt-6 px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Pr√≥xima Quest√£o</button>
    </div>

    <div id="result-screen" class="hidden text-center">
      <h2 class="text-2xl font-bold mb-4">Resultado</h2>
      <p id="score" class="mb-4 text-lg"></p>
      <div id="review" class="text-left space-y-4"></div>
      <button onclick="location.reload()" class="mt-6 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700">Refazer Simulado</button>
    </div>
  </div>

  <script>
    const quizData = [
      {
    question: "Qual foi o principal motivo para o desenvolvimento do PIM nos anos 1990?",
    options: ["Substituir o protocolo IGMP", "Superar as limita√ß√µes dos protocolos anteriores como DVMRP e MOSPF", "Criar redes sem fio", "Implementar IPv6"],
    answer: "Superar as limita√ß√µes dos protocolos anteriores como DVMRP e MOSPF",
    explanation: "O PIM foi desenvolvido para superar as limita√ß√µes significativas dos protocolos anteriores em termos de escalabilidade, permitindo que funcionasse sobre qualquer protocolo de roteamento unicast."
  },
  {
    question: "O que significa o termo 'Protocol Independent' no nome PIM?",
    options: ["N√£o depende de outros protocolos", "Permite que o PIM funcione sobre qualquer protocolo de roteamento unicast", "√â independente da topologia de rede", "Funciona apenas com protocolos propriet√°rios"],
    answer: "Permite que o PIM funcione sobre qualquer protocolo de roteamento unicast",
    explanation: "O conceito 'Protocol Independent' foi revolucion√°rio, permitindo que o PIM funcionasse sobre qualquer protocolo de roteamento unicast (OSPF, BGP, RIP, etc.), consultando a tabela RIB (Routing Information Base)."
  },
  {
    question: "Qual RFC padronizou o PIM-SM vers√£o 2?",
    options: ["RFC 2362", "RFC 4601", "RFC 3973", "RFC 1112"],
    answer: "RFC 4601",
    explanation: "A RFC 4601 (2006) padronizou o PIM-SM vers√£o 2, sendo uma revis√£o e atualiza√ß√£o da RFC 2362 (1998) que especificou a vers√£o inicial."
  },
  {
    question: "Qual √© a principal diferen√ßa entre Source Tree (S,G) e Shared Tree (*,G)?",
    options: ["Source Tree usa menos mem√≥ria", "Source Tree tem caminho espec√≠fico por origem, Shared Tree compartilha um ponto central", "Shared Tree √© mais r√°pido", "Source Tree funciona apenas com IPv6"],
    answer: "Source Tree tem caminho espec√≠fico por origem, Shared Tree compartilha um ponto central",
    explanation: "Source Tree (S,G) cria uma √°rvore espec√≠fica para cada origem, oferecendo caminho mais curto. Shared Tree (*,G) usa um Rendezvous Point (RP) central, consumindo menos mem√≥ria mas podendo n√£o oferecer o caminho mais curto."
  },
  {
    question: "No PIM Dense Mode, qual √© a filosofia de opera√ß√£o?",
    options: ["Pull Model - controla sob demanda", "Push Model - inunda primeiro, depois poda", "Hybrid Model - combina ambos", "Static Model - rotas fixas"],
    answer: "Push Model - inunda primeiro, depois poda",
    explanation: "O PIM Dense Mode opera no modelo 'Flood and Prune' (inunda primeiro, depois poda), assumindo que todos querem o tr√°fego multicast inicialmente, removendo depois onde n√£o h√° interesse."
  },
  {
    question: "Qual modo do PIM √© mais adequado para cen√°rios com receptores esparsos na rede?",
    options: ["PIM Dense Mode (PIM-DM)", "PIM Sparse Mode (PIM-SM)", "PIM Bidirectional (PIM-BIDIR)", "PIM Source-Specific Multicast (PIM-SSM)"],
    answer: "PIM Sparse Mode (PIM-SM)",
    explanation: "O PIM Sparse Mode opera no 'Pull Model', controlando sob demanda, sendo mais eficiente quando os receptores est√£o esparsamente distribu√≠dos pela rede, evitando tr√°fego desnecess√°rio."
  },
  {
    question: "No PIM-SSM, qual informa√ß√£o os receptores devem especificar?",
    options: ["Apenas o grupo multicast", "Apenas a origem", "Tanto a origem quanto o grupo", "Apenas a interface de rede"],
    answer: "Tanto a origem quanto o grupo",
    explanation: "No PIM Source-Specific Multicast (PIM-SSM), os receptores devem conhecer e especificar tanto a origem quanto o grupo, eliminando problemas de seguran√ßa do multicast tradicional."
  },
  {
    question: "Qual √© uma das principais caracter√≠sticas do PIM em rela√ß√£o ao uso de largura de banda?",
    options: ["Aumenta o uso de largura de banda", "Otimiza o uso da largura de banda evitando duplica√ß√£o desnecess√°ria", "N√£o afeta a largura de banda", "Funciona apenas em redes de alta velocidade"],
    answer: "Otimiza o uso da largura de banda evitando duplica√ß√£o desnecess√°ria",
    explanation: "O PIM constr√≥i √°rvores de distribui√ß√£o para entregar tr√°fego multicast de forma eficiente, otimizando o uso da largura de banda ao evitar duplica√ß√£o desnecess√°ria de pacotes."
  },
  {
    question: "Como o PIM determina os caminhos de roteamento para o tr√°fego multicast?",
    options: ["Cria sua pr√≥pria tabela de roteamento", "Consulta a tabela RIB (Routing Information Base)", "Usa apenas rotas est√°ticas", "Depende exclusivamente do protocolo OSPF"],
    answer: "Consulta a tabela RIB (Routing Information Base)",
    explanation: "O PIM consulta a tabela RIB (Routing Information Base) para determinar os caminhos, sendo 'independente de protocolo' pois pode usar informa√ß√µes de qualquer protocolo de roteamento unicast (BGP, OSPF, RIP, etc.)."
  },
  {
    question: "Qual √© a faixa de endere√ßos utilizada no exemplo de PIM-SSM mencionado no material?",
    options: ["224.0.0.0/8", "239.0.0.0/8", "232.0.0.0/8", "233.0.0.0/8"],
    answer: "232.0.0.0/8",
    explanation: "O PIM-SSM utiliza a faixa de endere√ßos 232.0.0.0/8 para grupos Source-Specific Multicast, onde os receptores devem especificar tanto a origem quanto o grupo multicast."
  }  
      // üëâ Adicione mais quest√µes aqui
    ];

    // Randomiza ordem das quest√µes
    quizData.sort(() => Math.random() - 0.5);

    let currentQuestionIndex = 0;
    let score = 0;
    let timer;
    const totalTime = 10 * 60;
    
    // Armazena as respostas do usu√°rio para revis√£o
    let userAnswers = [];

    const startScreen = document.getElementById("start-screen");
    const quizScreen = document.getElementById("quiz-screen");
    const resultScreen = document.getElementById("result-screen");
    const questionTextEl = document.getElementById("question-text");
    const optionsContainer = document.getElementById("options");
    const nextBtn = document.getElementById("next-btn");
    const scoreEl = document.getElementById("score");
    const questionNumberEl = document.getElementById("question-number");
    const timerEl = document.getElementById("timer");
    const reviewEl = document.getElementById("review");

const SIMULADO_ID = "teste01";
const SIMULADO_TITULO = document.title || "Simulado";
let startTime = null;
let currentUserName = "";

// Helpers para salvar resultados no LocalStorage
function formatSeconds(s) {
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}
function saveResult(record) {
  try {
    const raw = localStorage.getItem("simulados");
    const arr = raw ? JSON.parse(raw) : [];
    arr.push(record);
    localStorage.setItem("simulados", JSON.stringify(arr));
  } catch (e) { console.warn("Falha ao salvar resultado:", e); }
}


    function startQuiz() {
  const nameInput = document.getElementById("user-name");
  const nameVal = (nameInput?.value || "").trim();
  if (!nameVal) { alert("Por favor, informe seu nome antes de iniciar."); return; }
  currentUserName = nameVal;
  startTime = Date.now();
      startScreen.classList.add("hidden");
      quizScreen.classList.remove("hidden");
      showQuestion();
      startTimer();
    }

    function startTimer() {
      let timeLeft = totalTime;
      timer = setInterval(() => {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerEl.textContent = `Tempo: ${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
        if (timeLeft-- <= 0) {
          clearInterval(timer);
          showResults();
        }
      }, 1000);
    }

    function updateProgressBar() {
      const progress = ((currentQuestionIndex + 1) / quizData.length) * 100;
      document.getElementById('progress-bar').style.width = `${progress}%`;
    }

    function showQuestion() {
      const q = quizData[currentQuestionIndex];
      questionNumberEl.textContent = `${currentQuestionIndex+1}/${quizData.length}`;
      questionTextEl.textContent = q.question;
      optionsContainer.innerHTML = '';

      const shuffled = [...q.options].sort(() => Math.random() - 0.5);
      shuffled.forEach(opt => {
        const b = document.createElement("button");
        b.textContent = opt;
        b.classList.add("quiz-option","w-full","text-left","p-4","border-2","rounded-lg","transition-colors","duration-200","hover:bg-blue-100","hover:border-blue-400");
        b.onclick = () => selectOption(b, opt);
        optionsContainer.appendChild(b);
      });

      nextBtn.textContent = currentQuestionIndex === quizData.length - 1 ? "Ver Resultados" : "Pr√≥xima Quest√£o";
      nextBtn.disabled = true;

      updateProgressBar();
    }

    function selectOption(button, selected) {
      const q = quizData[currentQuestionIndex];
      const buttons = document.querySelectorAll(".quiz-option");

      buttons.forEach(b => b.disabled = true);

      // Armazena a resposta do usu√°rio para a revis√£o
      userAnswers[currentQuestionIndex] = selected;

      if (selected === q.answer) {
        button.classList.add("bg-green-200","border-green-600");
        score++;
      } else {
        button.classList.add("bg-red-200","border-red-600");
        buttons.forEach(b => {
          if (b.textContent === q.answer) b.classList.add("bg-green-200","border-green-600");
        });
      }

      nextBtn.disabled = false;
    }

    function nextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex < quizData.length) {
        showQuestion();
      } else {
        showResults();
      }
    }

    function showResults() {
  const endTime = Date.now();
  const timeSpentSeconds = startTime ? Math.round((endTime - startTime) / 1000) : 0;
  const resultRecord = {
    id: String(Date.now()),
    simuladoId: SIMULADO_ID,
    simuladoTitle: SIMULADO_TITULO,
    name: currentUserName,
    score: score,
    total: quizData.length,
    percent: quizData.length ? (score / quizData.length) * 100 : 0,
    timeSeconds: timeSpentSeconds,
    timeFormatted: formatSeconds(timeSpentSeconds),
    date: new Date().toISOString()
  };
  saveResult(resultRecord);
      clearInterval(timer);
      quizScreen.classList.add("hidden");
      resultScreen.classList.remove("hidden");

      const pct = quizData.length ? Math.round((score/quizData.length)*100) : 0;
scoreEl.textContent = `Voc√™ acertou ${score} de ${quizData.length} quest√µes (${pct}%). Tempo: ${formatSeconds(timeSpentSeconds)}.`;

      reviewEl.innerHTML = quizData.map((q, i) => {
        const isCorrect = userAnswers[i] === q.answer;
        const resultClass = isCorrect ? "bg-green-100 border-green-600" : "bg-red-100 border-red-600";
        return `
          <div class="p-4 border rounded-lg ${resultClass}">
            <p class="font-semibold">Q${i+1}: ${q.question}</p>
            <p class="text-sm">Sua resposta: <span class="font-semibold">${userAnswers[i] || 'N√£o respondida'}</span></p>
            <p class="text-sm">Resposta correta: <span class="font-semibold">${q.answer}</span></p>
            <p class="text-slate-600 text-sm mt-1">${q.explanation}</p>
          </div>
        `;
      }).join('');
    }
  </script>
</body>
</html>